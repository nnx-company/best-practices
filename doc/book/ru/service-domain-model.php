# Принципы построения доменной модели

Одна из основных причин разделение сервиа на два слоя:

- Абстрактая часть сервиса
- Конфигурация сервиса под конкретную информационную систему

это дать возможность дорабатывать доменную модель под конкретного заказчика.

Рассмотрим принципы построения доменной модели сервиса на примере.

Есть две информационные системы для разных заказчиков *customer1* и *customer2*. Цель разработать сервис контактов, для
эти двух информационных систем. Одним из требований является то, что информация о организациях, в этих информационных системах
имеет разную структуру.

Для каждого из заказчиков создается два приложения, каждое из которых является контейнером для сервиса контактов.
Упрощенная структура модулей:

- Приложение-контейнер для сервиса контактов заказчика *customer1*:

```text
project
    vendor
        nnx-contract
            contract
            contract-core
        customer1-contract
            organization
```

- Приложение-контейнер для сервиса контактов заказчика *customer2*:

```text
project
    vendor
        nnx-contract
            contract
            contract-core
        customer2-contract
            organization
```

Т.е реализация сущностей, подстраивающих доменную модель под конкретного заказчика, выноситься в соответствующие модули
*customer1-contract\organization* и *customer2-contract\organization*.

## Доменная модель в Core модулях.

У каждого сервиса есть Core модуль, в котором сосредоточенно описание базовых сущностей сервиса, а также предоставляются
сервисы, для работы с наиболее общим функционалом.

Спецификой Core модулей, является то, что в сервисах расположенных в данных модулях, неизвестно с каким именно классом
сущности будет происходить работа.

В случае модуля *nnx-contract/contract-core* заранее неизвестно имя класса организации. Так как сущность организации которая
будет исспользоваться в сервисе, может быть реализованна в другом модуле (в приведенном примере это *customer1-contract\organization* и *customer2-contract\organization*).

Для достижения такой гибкости используется следующий подход:

- Для каждой сущности, которая может рассширяться в других модулях заводиться интерфейс
- В рамках сервиса модуля, работа осуществляется с объектами имлементирующим заданный интерфейс, т.е. **не допускается использовать имена классов**
- Если есть часть свойст которые гарантированно будут у всех классов имплементирующих данный интерфейс, то создается абстрактный класс
- Создается класс сущности являющейся родительской, для сущностей распологаемых в других модуля

Расмотрим конкретный пример:

